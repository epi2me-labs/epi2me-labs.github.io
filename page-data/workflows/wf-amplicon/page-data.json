{"componentChunkName":"component---packages-blog-gatsby-blog-core-src-templates-post-js","path":"/workflows/wf-amplicon/","result":{"data":{"post":{"id":"1a47f5ba-11d4-5e2b-a748-ecfd43472404","title":"wf-amplicon documentation","slug":"/workflows/wf-amplicon/","link":null,"excerpt":"Amplicon workflow Nextflow workflow for analysing Oxford Nanopore reads created from haploidâ€¦","tableOfContents":{"items":[{"url":"#amplicon-workflow","title":"Amplicon workflow","items":[{"url":"#introduction","title":"Introduction"},{"url":"#compute-requirements","title":"Compute requirements"},{"url":"#install-and-run","title":"Install and run"},{"url":"#related-protocols","title":"Related protocols"},{"url":"#input-example","title":"Input example"},{"url":"#input-parameters","title":"Input parameters"},{"url":"#outputs","title":"Outputs"},{"url":"#pipeline-overview","title":"Pipeline overview"},{"url":"#troubleshooting","title":"Troubleshooting"},{"url":"#faqs","title":"FAQ's"},{"url":"#related-blog-posts","title":"Related blog posts"}]}]},"timeToRead":8,"featured":null,"protected":null,"thumbnailText":null,"date":null,"category":null,"author":{"id":"06b83e26-dbcb-5a79-ab90-35cd748fd03f","name":"EPI2ME Labs","slug":"/author/epi2me-labs/","title":"Senior Button Pusher","description":"I'm a robot. I like to publish JupyterLab tutorials, Nextflow workflows, and blog posts.","skills":["Continuous Deployment"],"social":[{"name":"Twitter","url":"https://twitter.com/nanopore"},{"name":"Website","url":"https://labs.epi2me.io"}],"status":"bot","thumbnail":{"__typename":"ImageSharp","ImageSharp_small":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAACg0lEQVR42pVUy4tSYRTXO6EbH4GEKxc+wShBXE0gCNJ/oJsgTFxUmxbVrCSlrQvdVTMuRnQng6AJCeIqwhajqG1EBEloKRk+rnofX+dcviuDjVc7cDjfPed8P37n8V2V6nZhCCEM2Kdarfa70+mcu1yuOZ7B96xYLJ6AVauOFClRrVZ/ikQiZDQaCQAuoo7HYyEajRKIXSaTSeZm/j45ofZ5KBQiq9VqPZ1OudlsJq7Xa3EymXCCILAYg5xXO3f2i9lsbpbLZRIIBBY+n285HA65xWLBB4PBOX6fn59zFoulia1RYik7TV6vd7TZbAgA8f1+n6clEyiZ7/V6PLAkbrf7F+QajilbpdFovtVqNcRAMIHa7RljkPP1FjL/Tpfahzqd7jocDovpdFosFAoEFc/QP1Gv119jzs6dvSW7QG1Go/Eu2MegL0HPqL5AH8ZghWw0dy9DeVoXDoeDWK3WHyaT6bPBYLiE8j6g4hl9Nputa7fbcdIflSYtO9/l83mpfzAQ0m63SbPZlLTVahH0gXC5XA4BE/TOHSXAJ/F4XALkOE6kg5AHI1Afl0gkEDByDOApNH5DLxNcEVSe5wksuQDrJL0aGNgKch8pDUZu7D2Px/MTFhlZiiBoCQAJ2WyWBb9wYw9Nh9ZGCjAM86Xb7SKOdFmqn+fFRqOxwnI7nQ6BKVcxF76PesuvU6mU3EcJEHtXqVRYJJvJZLB/b5T6t7vYD+Ad/wZ225IBUCiVSuxyueQh9gdy7h9a7N1eXtXr9S1L+POIg8GArVaryO7qmHJ3WZ76/f4VsNzI/0Mkir5D01UCfR+LxQjLsjwq/lzR979g29JpSWfwDMeocH5LfXtL/QsFNN8CNdlHZwAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/c489ff6e3b007deccb15ccbd6b76ce51/a7a66/epi2melabs.png","srcSet":"/static/c489ff6e3b007deccb15ccbd6b76ce51/a7a66/epi2melabs.png 48w,\n/static/c489ff6e3b007deccb15ccbd6b76ce51/416a0/epi2melabs.png 96w","sizes":"48px"},"sources":[{"srcSet":"/static/c489ff6e3b007deccb15ccbd6b76ce51/a3542/epi2melabs.webp 48w,\n/static/c489ff6e3b007deccb15ccbd6b76ce51/0f66d/epi2melabs.webp 96w","type":"image/webp","sizes":"48px"}]},"width":48,"height":48},"ImageSharp_regular":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAACg0lEQVR42pVUy4tSYRTXO6EbH4GEKxc+wShBXE0gCNJ/oJsgTFxUmxbVrCSlrQvdVTMuRnQng6AJCeIqwhajqG1EBEloKRk+rnofX+dcviuDjVc7cDjfPed8P37n8V2V6nZhCCEM2Kdarfa70+mcu1yuOZ7B96xYLJ6AVauOFClRrVZ/ikQiZDQaCQAuoo7HYyEajRKIXSaTSeZm/j45ofZ5KBQiq9VqPZ1OudlsJq7Xa3EymXCCILAYg5xXO3f2i9lsbpbLZRIIBBY+n285HA65xWLBB4PBOX6fn59zFoulia1RYik7TV6vd7TZbAgA8f1+n6clEyiZ7/V6PLAkbrf7F+QajilbpdFovtVqNcRAMIHa7RljkPP1FjL/Tpfahzqd7jocDovpdFosFAoEFc/QP1Gv119jzs6dvSW7QG1Go/Eu2MegL0HPqL5AH8ZghWw0dy9DeVoXDoeDWK3WHyaT6bPBYLiE8j6g4hl9Nputa7fbcdIflSYtO9/l83mpfzAQ0m63SbPZlLTVahH0gXC5XA4BE/TOHSXAJ/F4XALkOE6kg5AHI1Afl0gkEDByDOApNH5DLxNcEVSe5wksuQDrJL0aGNgKch8pDUZu7D2Px/MTFhlZiiBoCQAJ2WyWBb9wYw9Nh9ZGCjAM86Xb7SKOdFmqn+fFRqOxwnI7nQ6BKVcxF76PesuvU6mU3EcJEHtXqVRYJJvJZLB/b5T6t7vYD+Ad/wZ225IBUCiVSuxyueQh9gdy7h9a7N1eXtXr9S1L+POIg8GArVaryO7qmHJ3WZ76/f4VsNzI/0Mkir5D01UCfR+LxQjLsjwq/lzR979g29JpSWfwDMeocH5LfXtL/QsFNN8CNdlHZwAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/c489ff6e3b007deccb15ccbd6b76ce51/46e60/epi2melabs.png","srcSet":"/static/c489ff6e3b007deccb15ccbd6b76ce51/46e60/epi2melabs.png 150w,\n/static/c489ff6e3b007deccb15ccbd6b76ce51/d612b/epi2melabs.png 300w","sizes":"150px"},"sources":[{"srcSet":"/static/c489ff6e3b007deccb15ccbd6b76ce51/ae23d/epi2melabs.webp 150w,\n/static/c489ff6e3b007deccb15ccbd6b76ce51/bd37b/epi2melabs.webp 300w","type":"image/webp","sizes":"150px"}]},"width":150,"height":150}}},"body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"wf-amplicon documentation\",\n  \"slug\": \"workflows/wf-amplicon\",\n  \"author\": \"EPI2ME Labs\",\n  \"private\": true,\n  \"category\": \"Workflows\",\n  \"keywords\": [\"epi2melabs\", \"nanopore sequencing\"],\n  \"description\": \"Documentation for the wf-amplicon workflow.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"amplicon-workflow\"\n  }, \"Amplicon workflow\"), mdx(\"p\", null, \"Nextflow workflow for analysing Oxford Nanopore reads created from haploid amplicons.\"), mdx(\"h2\", {\n    \"id\": \"introduction\"\n  }, \"Introduction\"), mdx(\"p\", null, \"This \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.nextflow.io/\"\n  }, \"Nextflow\"), \" workflow provides a simple way to\\nanalyse Oxford Nanopore reads generated from haploid amplicons.\"), mdx(\"p\", null, \"The workflow requires raw reads in FASTQ format and can be run in two modes:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Variant calling mode: Trigger this mode by passing a reference FASTA file.\\nAfter initial filtering (based on read length and quality) and adapter\\ntrimming, \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/lh3/minimap2\"\n  }, \"minimap2\"), \" is used to align the\\nreads to the reference. Variants are then called with\\n\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/nanoporetech/medaka\"\n  }, \"Medaka\"), \". This mode allows for\\nmultiple amplicons per barcode (before running with multiple amplicons per\\nbarcode, please read the relevant sections in the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#pipeline-overview\"\n  }, \"Pipeline Overview\"), \" and \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#FAQs\"\n  }, \"FAQs\"), \" below).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"De-novo consensus mode: This mode is run when no reference file is passed.\\nLike for the \\u201Cvariant calling mode\\u201D, reads are first filtered and trimmed.\\nThen, a consensus sequence is generated \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"de novo\"), \" from the reads of each\\nsample. Reads are re-aligned against the draft consensus for polishing with\\n\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/nanoporetech/medaka\"\n  }, \"Medaka\"), \". Please note that only one\\namplicon per barcode is supported in de-novo consensus mode.\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note: The amplicons analysed with this workflow need to be haploid.\\nwf-amplicon is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" intended for diploid (e.g. human) samples or marker gene sequencing of mixtures / communities comprised of different organisms (e.g. 16S sequencing).\\nIn de-novo consensus mode the workflow expects a single amplicon per barcode.\\nWhen running in variant calling mode, multiple amplicons per barcode can be processed, but their sequences need to be sufficiently different from each other so that most reads only align to one of the provided references.\")), mdx(\"h2\", {\n    \"id\": \"compute-requirements\"\n  }, \"Compute requirements\"), mdx(\"p\", null, \"Recommended requirements:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"CPUs = 12\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Memory = 32GB\")), mdx(\"p\", null, \"Minimum requirements:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"CPUs = 6\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Memory = 16GB\")), mdx(\"p\", null, \"Approximate run time: 0.5-5 minutes per sample (depending on number of reads, length of amplicons, and available compute).\"), mdx(\"p\", null, \"ARM processor support: True\"), mdx(\"h2\", {\n    \"id\": \"install-and-run\"\n  }, \"Install and run\"), mdx(\"p\", null, \"These are instructions to install and run the workflow on command line.\\nYou can also access the workflow via the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://labs.epi2me.io/downloads/\"\n  }, \"EPI2ME Desktop application\"), \".\"), mdx(\"p\", null, \"The workflow uses \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.nextflow.io/\"\n  }, \"Nextflow\"), \" to manage\\ncompute and software resources,\\ntherefore Nextflow will need to be\\ninstalled before attempting to run the workflow.\"), mdx(\"p\", null, \"The workflow can currently be run using either\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.docker.com/products/docker-desktop\"\n  }, \"Docker\"), \"\\nor \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.sylabs.io/guides/3.0/user-guide/index.html\"\n  }, \"Singularity\"), \"\\nto provide isolation of the required software.\\nBoth methods are automated out-of-the-box provided\\neither Docker or Singularity is installed.\\nThis is controlled by the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.nextflow.io/docs/latest/config.html#config-profiles\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"-profile\")), \"\\nparameter as exemplified below.\"), mdx(\"p\", null, \"It is not required to clone or download the git repository\\nin order to run the workflow.\\nMore information on running EPI2ME workflows can\\nbe found on our \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://labs.epi2me.io/wfindex\"\n  }, \"website\"), \".\"), mdx(\"p\", null, \"The following command can be used to obtain the workflow.\\nThis will pull the repository in to the assets folder of\\nNextflow and provide a list of all parameters\\navailable for the workflow as well as an example command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"nextflow run epi2me-labs/wf-amplicon --help\\n\")), mdx(\"p\", null, \"To update a workflow to the latest version on the command line use\\nthe following command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"nextflow pull epi2me-labs/wf-amplicon\\n\")), mdx(\"p\", null, \"A demo dataset is provided for testing of the workflow.\\nIt can be downloaded and unpacked using the following commands:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"wget https://ont-exd-int-s3-euwst1-epi2me-labs.s3.amazonaws.com/wf-amplicon/wf-amplicon-demo.tar.gz\\ntar -xzvf wf-amplicon-demo.tar.gz\\n\")), mdx(\"p\", null, \"The workflow can then be run with the downloaded demo data using:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"nextflow run epi2me-labs/wf-amplicon \\\\\\n    --fastq 'wf-amplicon-demo/fastq' \\\\\\n    --reference 'wf-amplicon-demo/reference.fa' \\\\\\n    -profile standard\\n\")), mdx(\"p\", null, \"For further information about running a workflow on\\nthe command line see \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://labs.epi2me.io/wfquickstart/\"\n  }, \"https://labs.epi2me.io/wfquickstart/\")), mdx(\"h2\", {\n    \"id\": \"related-protocols\"\n  }, \"Related protocols\"), mdx(\"p\", null, \"This workflow is designed to take input sequences that have been produced from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://nanoporetech.com/\"\n  }, \"Oxford Nanopore Technologies\"), \" devices.\"), mdx(\"p\", null, \"Find related protocols in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://community.nanoporetech.com/docs/\"\n  }, \"Nanopore community\"), \".\"), mdx(\"h2\", {\n    \"id\": \"input-example\"\n  }, \"Input example\"), mdx(\"p\", null, \"This workflow accepts FASTQ files as input.\"), mdx(\"p\", null, \"The FASTQ input parameters for this workflow accept one of three cases: (i) the path to a single FASTQ file; (ii) the path to a top-level directory containing FASTQ files; (iii) the path to a directory containing one level of sub-directories which in turn contain FASTQ files. In the first and second cases (i and ii), a sample name can be supplied with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--sample\"), \". In the last case (iii), the data is assumed to be multiplexed with the names of the sub-directories as barcodes. In this case, a sample sheet can be provided with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--sample_sheet\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(i)                     (ii)                 (iii)\\ninput_reads.fastq   \\u2500\\u2500\\u2500 input_directory  \\u2500\\u2500\\u2500 input_directory\\n                        \\u251C\\u2500\\u2500 reads0.fastq     \\u251C\\u2500\\u2500 barcode01\\n                        \\u2514\\u2500\\u2500 reads1.fastq     \\u2502   \\u251C\\u2500\\u2500 reads0.fastq\\n                                             \\u2502   \\u2514\\u2500\\u2500 reads1.fastq\\n                                             \\u251C\\u2500\\u2500 barcode02\\n                                             \\u2502   \\u251C\\u2500\\u2500 reads0.fastq\\n                                             \\u2502   \\u251C\\u2500\\u2500 reads1.fastq\\n                                             \\u2502   \\u2514\\u2500\\u2500 reads2.fastq\\n                                             \\u2514\\u2500\\u2500 barcode03\\n                                              \\u2514\\u2500\\u2500 reads0.fastq\\n\")), mdx(\"h2\", {\n    \"id\": \"input-parameters\"\n  }, \"Input parameters\"), mdx(\"h3\", {\n    \"id\": \"input-options\"\n  }, \"Input Options\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Nextflow parameter name\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Help\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Default\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"fastq\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"FASTQ files to use in the analysis.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"This accepts one of three cases: (i) the path to a single FASTQ file; (ii) the path to a top-level directory containing FASTQ files; (iii) the path to a directory containing one level of sub-directories which in turn contain FASTQ files. In the first and second case, a sample name can be supplied with \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"--sample\"), \". In the last case, the data is assumed to be multiplexed with the names of the sub-directories as barcodes. In this case, a sample sheet can be provided with \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"--sample_sheet\"), \".\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"analyse_unclassified\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"boolean\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Analyse unclassified reads from input directory. By default the workflow will not process reads in the unclassified directory.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"If selected and if the input is a multiplex directory the workflow will also process the unclassified directory.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"False\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"reads_downsampling_size\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Downsample to this number of reads per sample.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Downsampling is performed after filtering. Downsampling is performed by default to improve performance. Set to 0 to disable downsampling and use all data for analysis. Increasing the downsampling size (or setting it to zero) may lead to excessive memory consumption.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1500\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"reference\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Path to a reference FASTA file.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The reference file should contain one sequence per amplicon.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })))), mdx(\"h3\", {\n    \"id\": \"sample-options\"\n  }, \"Sample Options\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Nextflow parameter name\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Help\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Default\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"sample_sheet\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"A CSV file used to map barcodes to sample aliases. The sample sheet can be provided when the input data is a directory containing sub-directories with FASTQ files.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The sample sheet is a CSV file with, minimally, columns named \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"barcode\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"alias\"), \". Extra columns are allowed. In variant calling mode, a \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"ref\"), \" column can be added to tell the workflow which reference sequences should be used for which samples (please see the FAQs section in the documentation for details).\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"sample\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"A single sample name for non-multiplexed data. Permissible if passing a single .fastq(.gz) file or directory of .fastq(.gz) files.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })))), mdx(\"h3\", {\n    \"id\": \"pre-processing-options\"\n  }, \"Pre-processing Options\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Nextflow parameter name\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Help\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Default\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"min_read_length\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Shorter reads will be removed.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"300\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"max_read_length\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Longer reads will be removed.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"min_read_qual\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"number\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Reads with a lower mean quality will be removed.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"10\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"drop_frac_longest_reads\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"number\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Drop fraction of longest reads.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The very longest reads might be concatemers or contain other artifacts. In many cases removing them simplifies de novo consensus generation. When running variant calling mode with multiple amplicons per sample, it is recommended to set this to 0.0.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"0.05\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"take_longest_remaining_reads\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"boolean\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Whether to use the longest (remaining) reads.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"With this option enabled, reads are not randomly selected during downsampling. Instead, after dropping the longest reads (unless the \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"drop_frac_longest_reads\"), \" parameter is set to 0) the longest remaining reads are kept. This is recommended for de-novo mode when working with long amplicons. When running variant calling mode with multiple amplicons per sample, it is recommended to disable this option.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"True\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"min_n_reads\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"number\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Samples / barcodes with fewer reads will not be processed.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"40\")))), mdx(\"h3\", {\n    \"id\": \"variant-calling-options\"\n  }, \"Variant Calling Options\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Nextflow parameter name\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Help\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Default\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"min_coverage\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Minimum coverage for variants to keep.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Only variants covered by more than this number of reads are reported in the resulting VCF file.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"20\")))), mdx(\"h3\", {\n    \"id\": \"de-novo-consensus-options\"\n  }, \"De-novo Consensus Options\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Nextflow parameter name\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Help\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Default\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"force_spoa_length_threshold\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Consensus length below which to force SPOA consensus generation.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"If the consensus generated by \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"miniasm\"), \" is shorter than this value, force consensus generation with SPOA (regardless of whether the sequence produced by \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"miniasm\"), \" passed QC or not). The rationale for this parameter is that \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"miniasm\"), \" sometimes gives slightly truncated assemblies for short amplicons from RBK data, whereas SPOA tends to be more robust in this regard.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2000\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"spoa_minimum_relative_coverage\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"number\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Minimum coverage (relative to the number of reads per sample after filtering) when constructing the consensus with SPOA.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Needs to be a number between 0.0 and 1.0. The result of multiplying this number with the number of reads for the corresponding sample (after filtering) is passed on to SPOA\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"--min-coverage\"), \" option.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"0.15\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"minimum_mean_depth\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Mean depth threshold to pass consensus quality control.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Draft consensus sequences with a lower average depth of coverage after re-aligning the input reads will fail QC.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"30\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"primary_alignments_threshold\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"number\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Fraction of primary alignments to pass quality control.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Draft consensus sequences with a lower fraction of primary alignments after re-aligning the input reads will fail QC.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"0.7\")))), mdx(\"h3\", {\n    \"id\": \"output-options\"\n  }, \"Output Options\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Nextflow parameter name\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Help\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Default\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"out_dir\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Directory for output of all workflow results.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"output\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"combine_results\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"boolean\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Whether to merge per-sample results into a single BAM / VCF file.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Per default, results are grouped per sample. With this option, an additional BAM and VCF file are produced which contain the alignments / variants for all samples and amplicons.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"False\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"igv\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"boolean\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Enable IGV visualisation in the EPI2ME Desktop Application by creating the required files.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"False\")))), mdx(\"h3\", {\n    \"id\": \"advanced-options\"\n  }, \"Advanced Options\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Nextflow parameter name\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Help\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Default\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"number_depth_windows\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Number of windows used during depth of coverage calculations.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Depth of coverage is calculated for each sample across each amplicon split into this number of windows. A higher number will produce more fine-grained plots at the expense of run time.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"100\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"medaka_target_depth_per_strand\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Downsample each amplicon to this per-strand depth before running Medaka.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Medaka performs best with even strand coverage and depths between 80X and 400X. To avoid too high coverage, the workflow downsamples the reads for each amplicon to this per-strand depth before running Medaka. Changing this value is discouraged as it might cause decreased performance.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"150\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"override_basecaller_cfg\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Override auto-detected basecaller model that processed the signal data; used to select an appropriate Medaka model.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Per default, the workflow tries to determine the basecall model from the input data. This parameter can be used to override the detected value (or to provide a model name if none was found in the inputs). However, users should only do this if they know for certain which model was used as selecting the wrong option might give sub-optimal results. A list of recent models can be found here: \", mdx(\"a\", {\n    parentName: \"td\",\n    \"href\": \"https://github.com/nanoporetech/dorado#DNA-models\"\n  }, \"https://github.com/nanoporetech/dorado#DNA-models\"), \".\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })))), mdx(\"h3\", {\n    \"id\": \"miscellaneous-options\"\n  }, \"Miscellaneous Options\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Nextflow parameter name\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Help\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Default\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"threads\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Maximum number of CPU threads to use per workflow task.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Several tasks in this workflow benefit from using multiple CPU threads. This option sets the maximum number of CPU threads for such processes. The total CPU resources used by the workflow are constrained by the Nextflow executor configuration.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"4\")))), mdx(\"h2\", {\n    \"id\": \"outputs\"\n  }, \"Outputs\"), mdx(\"p\", null, \"Output files may be aggregated including information for all samples or provided per sample. Per-sample files will be prefixed with respective aliases and represented below as {{ alias }}.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Title\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"File path\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Per sample or aggregated\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"workflow report\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./wf-amplicon-report.html\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Report for all samples.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"aggregated\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Sanitized reference file\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./reference_sanitized_seqIDs.fasta\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Some programs used by the workflow don\\u2019t like special characters (like colons) in the sequence IDs in the reference FASTA file. The reference is thus \\u201Csanitized\\u201D by replacing these characters with underscores. This file is only generated when the workflow is run in variant calling mode.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"aggregated\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Sanitized reference index file\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./reference_sanitized_seqIDs.fasta.fai\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"FAI index for the sanitised reference FASTA file.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"aggregated\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Alignments BAM file\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/alignments/{{ alias }}.aligned.sorted.bam\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"BAM file with alignments of input reads against the references (in variant calling mode) or the created consensus (in de-novo consensus mode).\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Alignments index file\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/alignments/{{ alias }}.aligned.sorted.bam.bai\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Index for alignments BAM file.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"De-novo consensus FASTQ file\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/consensus/consensus.fastq\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Consensus sequence file generated by de-novo consensus pipeline.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Consensus FASTA file\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/consensus/medaka.consensus.fasta\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Consensus sequence file generated by variant calling pipeline.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Variants VCF file\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/variants/medaka.annotated.vcf.gz\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"VCF file of variants detected against the provided reference.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Variants index file\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/variants/medaka.annotated.vcf.gz.csi\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Index for variants VCF file.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Combined de-novo consensus sequences\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./all-consensus-seqs.fasta\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"FASTA file containing all de-novo consensus sequences.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"aggregated\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Combined de-novo consensus sequences index\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./all-consensus-seqs.fasta.fai\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"FAI index for the FASTA file with the combined de-novo consensus sequences.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"aggregated\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"IGV config JSON file\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./igv.json\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"JSON file with IGV config options to be used by the EPI2ME Desktop Application.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"aggregated\")))), mdx(\"h2\", {\n    \"id\": \"pipeline-overview\"\n  }, \"Pipeline overview\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note: The initial preprocessing steps are the same for the variant calling and the de-novo consensus mode.\")), mdx(\"h4\", {\n    \"id\": \"1-read-preprocessing\"\n  }, \"1. Read preprocessing\"), mdx(\"p\", null, \"The input data can be a single FASTQ file, a directory containing FASTQ files, or a directory containing barcoded sub-directories which in turn contain FASTQ files.\\nA sample sheet can be included with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--sample_sheet\"), \" and a sample name for an individual sample with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--sample\"), \".\\nIf a sample sheet is provided, it needs to contain at least these three columns:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"barcode\"), \": names of the sub-directories with the FASTQ files of the different\\nsamples\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"alias\"), \": sample names\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"type\"), \": sample types (needs to be one of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"test_sample\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"positive_control\"), \",\\n\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"negative_control\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"no_template_control\"), \")\")), mdx(\"p\", null, \"After parsing the sample sheet, the raw reads are filtered. Relevant options for filtering are\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"--min_read_length\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"--max_read_length\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"--min_read_qual\"))), mdx(\"p\", null, \"By default, reads are also downsampled.\\nThe workflow supports random downsampling as well as selecting reads based on read length.\\nSubsetting based on read length tends to work better for de-novo consensus generation and does not decrease performance of variant calling mode when running with only one amplicon per sample.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"--reads_downsampling_size\"), \": This controls the number of reads to keep per sample\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"--drop_frac_longest_reads\"), \": Drop a fraction (e.g. 0.05 for 5%) of the longest reads.\\nAs the very longest reads might stem from concatemers or other sequencing artifacts, they might interfere with consensus generation and it is generally better to remove them in de-novo consensus mode.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"--take_longest_remaining_reads\"), \": Use the longest reads instead of random downsampling; note that this is done after dropping the longest reads according to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"--drop_frac_longest_reads\"), \".\\nThis can be beneficial when assembling long amplicons in de-novo consensus mode in some cases.\")), mdx(\"p\", null, \"The default values for these parameters are listed in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#pre-processing-options\"\n  }, \"Inputs section\"), \".\\nThe defaults work well for\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"De-novo consensus mode.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Variant calling mode with one amplicon per sample.\")), mdx(\"p\", null, \"When running variant calling mode with more than one amplicon per sample we recommend changing the parameters to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--drop_frac_longest_reads 0 --take_longest_remaining_reads false\"), \" in order to perform random downsampling.\\nThe selected reads are then trimmed with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/rrwick/Porechop\"\n  }, \"Porechop\"), \" prior to downstream analysis.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note: Samples with fewer reads than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--min_n_reads\"), \" after preprocessing are ignored.\")), mdx(\"h3\", {\n    \"id\": \"variant-calling-mode\"\n  }, \"Variant calling mode\"), mdx(\"h4\", {\n    \"id\": \"2-align-reads\"\n  }, \"2. Align reads\"), mdx(\"p\", null, \"Preprocessed reads are aligned against the provided reference with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/lh3/minimap2\"\n  }, \"Minimap2\"), \" (please note that the reference should only contain the expected sequences of the individual amplicons).\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/epi2me-labs/fastcat#bamstats\"\n  }, \"Bamstats\"), \" is used to collate alignment statistics and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/brentp/mosdepth\"\n  }, \"mosdepth\"), \" to calculate the depth of coverage along the amplicon.\"), mdx(\"h4\", {\n    \"id\": \"3-call-variants\"\n  }, \"3. Call variants\"), mdx(\"p\", null, \"After alignment, haploid variants are called with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/nanoporetech/medaka\"\n  }, \"Medaka\"), \".\\nYou can set the minimum coverage a variant needs to exceed in order to be included in the results with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--min_coverage\"), \".\\nVariants with lower coverage will still be listed in the resulting VCF files, but with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LOW_DEPTH\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PASS\"), \" in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FILTER\"), \" column.\"), mdx(\"p\", null, \"The workflow automatically selects the appropriate \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/nanoporetech/medaka#models\"\n  }, \"Medaka model\"), \" based on the basecall model that was used to process the signal data.\\nIn most cases, the workflow should be able to determine the basecall model from the input data.\\nIf this is not possible, it can be provided with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--override_basecaller_cfg\"), \" parameter.\"), mdx(\"h4\", {\n    \"id\": \"4-use-the-variants-to-generate-a-consensus\"\n  }, \"4. Use the variants to generate a consensus\"), mdx(\"p\", null, \"The variants passing the depth filter are then incorporated in the reference to create the consensus sequence.\"), mdx(\"h3\", {\n    \"id\": \"de-novo-consensus-mode\"\n  }, \"De-novo consensus mode\"), mdx(\"h4\", {\n    \"id\": \"2-create-a-draft-consensus\"\n  }, \"2. Create a draft consensus\"), mdx(\"p\", null, \"When running in de-novo mode, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/lh3/miniasm\"\n  }, \"miniasm\"), \" or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/rvaser/spoa\"\n  }, \"SPOA\"), \" are used to create a draft consensus after the reads were selected and trimmed.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"miniasm\"), \" tends to work better for longer amplicons and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spoa\"), \" for shorter amplicons.\\nThe workflow attempts to create an assembly with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"miniasm\"), \" first.\\nIf this succeeds, the draft assembly is polished with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/lbcb-sci/racon\"\n  }, \"Racon\"), \" and the input reads are re-aligned against it.\\nThis is followed by some post-processing (trimming low-coverage regions from the ends) and quality control (QC).\\nDuring QC, the following sanity-checks are performed:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The mean coverage of the consensus needs to be above \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"--minimum_mean_depth\"), \" (default: 30X).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The fraction of primary alignments for the re-aligned reads needs to be more than\\n\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"--primary_alignment_threshold\"), \" (default: 70%). Large numbers of secondary /\\nsupplementary alignments indicate that something might have gone wrong during\\nassembly. If your amplicons contain long repetitive regions, you can lower\\nthis number.\")), mdx(\"p\", null, \"If more than one contig from the draft assembly passes these filters, the one with the highest coverage is selected.\"), mdx(\"p\", null, \"If assembly generation fails or none of the contigs produced by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"miniasm\"), \" pass QC, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spoa\"), \" is tried.\\nRegardless of how the draft consensus was generated (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"miniasm\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spoa\"), \"), a final polishing step with\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/nanoporetech/medaka\"\n  }, \"Medaka\"), \" is performed.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note: Since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spoa\"), \" tends to produce a better consensus than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"miniasm\"), \" for short amplicons, users can force the workflow to run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spoa\"), \" if the assembly created by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"miniasm\"), \" is shorter than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--force_spoa_length_threshold\"), \" (even if it passes QC).\")), mdx(\"h2\", {\n    \"id\": \"troubleshooting\"\n  }, \"Troubleshooting\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the workflow fails please run it with the demo data set to ensure the workflow itself is working. This will help us determine if the issue is related to the environment, input parameters or a bug.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Please see \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://labs.epi2me.io/trouble-shooting/\"\n  }, \"here\"), \" for how to resolve some common Nextflow issues and \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://labs.epi2me.io/how-to-exits/\"\n  }, \"here\"), \" for how to interpret command exit codes.\")), mdx(\"h2\", {\n    \"id\": \"faqs\"\n  }, \"FAQ\\u2019s\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Do I need to change any parameters or can I stick to the defaults?\"), \" - The default parameters have been set for optimal results when running de-novo consensus mode or variant calling mode with a single amplicon per sample with amplicon sizes between 500 and 5,000 bp.\\nWhen running variant calling mode with several amplicons per sample, we recommend setting \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--drop_frac_longest_reads 0 --take_longest_remaining_reads false\"), \".\\nAlso, when your amplicons are very long or short, it might be a good idea to change the minimum read length filter cutoff.\\nFor more details, please refer to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#pipeline-overview\"\n  }, \"Pipeline Overview\"), \".\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"How can I select which reference is paired with which sample when running variant calling mode with multiple amplicons?\"), \" - If you want to map specific reference sequences to specific amplicons, you can add a column named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ref\"), \" containing the respective target reference IDs to the sample sheet.\\nIf a barcode should be aligned against multiple reference sequences, their IDs can be included as a space-delimited list.\\nIf a specific sample should be aligned against all references, you can leave the corresponding cell in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ref\"), \" column blank.\\nConsider the following example with 4 barcodes and 2 sequences in the reference file. The sample sheet tells the workflow that the first two barcodes (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sample1\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sample2\"), \") are expected to contain\\nreads from both amplicons in the reference, whereas the other two samples only contain one amplicon each.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"barcode,alias,type,ref\\nbarcode01,sample1,test_sample,katG::NC_000962.3:2154725-2155670 rpoB::NC_000962.3:760285-761376\\nbarcode02,sample2,test_sample,\\nbarcode03,sample3,positive_control,katG::NC_000962.3:2154725-2155670\\nbarcode04,sample4,test_sample,rpoB::NC_000962.3:760285-761376\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"How much coverage do I need?\"), \" - We recommend >150X average coverage across the individual amplicons.\\n1500 reads per amplicon should thus be enough in the vast majority of cases.\\nYou can speed up execution time by setting \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--reads_downsampling_size 1500\"), \" (or to a smaller number if your amplicons are not longer than a few kb).\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Why does the workflow select reads based on length rather than random downsampling per default?\"), \" - Despite the workflow dropping reads containing adapter sequences in the middle (using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"porechop --discard_middle\"), \"), some reads in the input data stemming from concatemers or other PCR artifacts might still make it through preprocessing and could thus interfere with consensus generation.\\nA simple way to avoid this is to drop a small fraction (e.g. 5%) of longest reads.\\nFurthermore, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spoa\"), \" depends on the order of reads in the input and benefits from \\u201Cseeing\\u201D longer reads first.\\nTherefore, the following workflow options are used per default \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--drop_frac_longest_reads 0.05 --take_longest_remaining_reads\"), \".\\nThis essentially drops the longest 5% of reads and then takes selects the next longest reads (either all of them or the number specified with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--reads_downsampling_size\"), \").\\nTo disable the default behaviour and enforce random downsampling of input reads, use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--drop_frac_longest_reads 0 --take_longest_remaining_reads false\"), \".\\nDisabling the default behaviour in favour of random downsampling is generally recommended when running variant calling mode with multiple amplicons per sample.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Is there a difference between the consensus sequences created in variant calling and de-novo consensus mode?\"), \" - In variant calling mode, the consensus sequence is generated by applying the variants found by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/nanoporetech/medaka\"\n  }, \"Medaka\"), \" to the provided reference.\\nThis comes with the caveat that structural variants too large to be detected by Medaka are not going to be represented in the consensus.\\nFor this reason we suggest to always have a look at the coverage plots in the generated HTML report.\\nIn de-novo consensus mode, however, the consensus is generated either via assembly or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://doi.org/10.1093/bioinformatics/btg109\"\n  }, \"POA\"), \" and no prior information besides the reads is taken into account.\"), mdx(\"p\", null, \"If your question is not answered here, please report any issues or suggestions on the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/epi2me-labs/wf-alignment/issues\"\n  }, \"github issues\"), \" page or start a discussion on the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://community.nanoporetech.com/\"\n  }, \"community\"), \".\"), mdx(\"h2\", {\n    \"id\": \"related-blog-posts\"\n  }, \"Related blog posts\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://labs.epi2me.io/how-to-align/\"\n  }, \"How to align your data\"))), mdx(\"p\", null, \"See the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://labs.epi2me.io/\"\n  }, \"EPI2ME website\"), \" for lots of other resources and blog posts.\"));\n}\n;\nMDXContent.isMDXComponent = true;","keywords":["epi2melabs","nanopore sequencing"],"tags":null,"thumbnail":null},"categoryPosts":{"nodes":[{"id":"f29751d6-a8c4-5c63-85c9-560553c92264","title":"10x Genomics single-cell transcriptomics human cell lines","slug":"/sc-gemx-2025.02/","link":null,"excerpt":"This post details the release of  10x Genomics single cell  cDNA sequencing of two cell lines: 293Tâ€¦","timeToRead":1,"featured":null,"thumbnailText":null,"date":"February 23, 2025","category":null,"author":null,"thumbnail":{"__typename":"ImageSharp","ImageSharp_vertical":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/4cb51f87ac0e07dd668f258b698ccef3/144fe/transcripts.jpg","srcSet":"/static/4cb51f87ac0e07dd668f258b698ccef3/9d7b9/transcripts.jpg 190w,\n/static/4cb51f87ac0e07dd668f258b698ccef3/144fe/transcripts.jpg 380w","sizes":"(min-width: 380px) 380px, 100vw"},"sources":[{"srcSet":"/static/4cb51f87ac0e07dd668f258b698ccef3/228d6/transcripts.webp 190w,\n/static/4cb51f87ac0e07dd668f258b698ccef3/6b99c/transcripts.webp 380w","type":"image/webp","sizes":"(min-width: 380px) 380px, 100vw"}]},"width":380,"height":290},"ImageSharp_hero":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/4cb51f87ac0e07dd668f258b698ccef3/582da/transcripts.jpg","srcSet":"/static/4cb51f87ac0e07dd668f258b698ccef3/737e6/transcripts.jpg 500w,\n/static/4cb51f87ac0e07dd668f258b698ccef3/582da/transcripts.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/4cb51f87ac0e07dd668f258b698ccef3/e3a40/transcripts.webp 500w,\n/static/4cb51f87ac0e07dd668f258b698ccef3/29b4f/transcripts.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1600,"height":649.6}}},{"id":"50f0c7a7-25ba-52bb-9add-0b666d124597","title":"Oxford Nanopore Open Data project","slug":"/dataindex/","link":null,"excerpt":"The Oxford Nanopore Technologies Open Data (ont-open-data) provides reference sequencing data fromâ€¦","timeToRead":1,"featured":true,"thumbnailText":null,"date":"August 24, 2022","category":null,"author":null,"thumbnail":{"__typename":"ImageSharp","ImageSharp_vertical":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/d625388ba09b90e0b9b8a67a5e80bdb7/144fe/thumbnail.jpg","srcSet":"/static/d625388ba09b90e0b9b8a67a5e80bdb7/9d7b9/thumbnail.jpg 190w,\n/static/d625388ba09b90e0b9b8a67a5e80bdb7/144fe/thumbnail.jpg 380w","sizes":"(min-width: 380px) 380px, 100vw"},"sources":[{"srcSet":"/static/d625388ba09b90e0b9b8a67a5e80bdb7/228d6/thumbnail.webp 190w,\n/static/d625388ba09b90e0b9b8a67a5e80bdb7/6b99c/thumbnail.webp 380w","type":"image/webp","sizes":"(min-width: 380px) 380px, 100vw"}]},"width":380,"height":290},"ImageSharp_hero":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/d625388ba09b90e0b9b8a67a5e80bdb7/5e493/thumbnail.jpg","srcSet":"/static/d625388ba09b90e0b9b8a67a5e80bdb7/696c0/thumbnail.jpg 800w,\n/static/d625388ba09b90e0b9b8a67a5e80bdb7/5e493/thumbnail.jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"},"sources":[{"srcSet":"/static/d625388ba09b90e0b9b8a67a5e80bdb7/c9f06/thumbnail.webp 800w,\n/static/d625388ba09b90e0b9b8a67a5e80bdb7/f47df/thumbnail.webp 1600w","type":"image/webp","sizes":"(min-width: 1600px) 1600px, 100vw"}]},"width":1600,"height":650}}},{"id":"a6deba78-2dec-5837-8bad-862595a85a3a","title":"EPI2ME Desktop","slug":"/about/","link":null,"excerpt":"","timeToRead":1,"featured":true,"thumbnailText":null,"date":"September 01, 2020","category":null,"author":null,"thumbnail":{"__typename":"ImageSharp","ImageSharp_vertical":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/8d35c423ec9237afa3953eaa56a9a37f/144fe/crowd-informatics.jpg","srcSet":"/static/8d35c423ec9237afa3953eaa56a9a37f/9d7b9/crowd-informatics.jpg 190w,\n/static/8d35c423ec9237afa3953eaa56a9a37f/144fe/crowd-informatics.jpg 380w","sizes":"(min-width: 380px) 380px, 100vw"},"sources":[{"srcSet":"/static/8d35c423ec9237afa3953eaa56a9a37f/228d6/crowd-informatics.webp 190w,\n/static/8d35c423ec9237afa3953eaa56a9a37f/6b99c/crowd-informatics.webp 380w","type":"image/webp","sizes":"(min-width: 380px) 380px, 100vw"}]},"width":380,"height":290},"ImageSharp_hero":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/8d35c423ec9237afa3953eaa56a9a37f/5e493/crowd-informatics.jpg","srcSet":"/static/8d35c423ec9237afa3953eaa56a9a37f/696c0/crowd-informatics.jpg 800w,\n/static/8d35c423ec9237afa3953eaa56a9a37f/5e493/crowd-informatics.jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"},"sources":[{"srcSet":"/static/8d35c423ec9237afa3953eaa56a9a37f/c9f06/crowd-informatics.webp 800w,\n/static/8d35c423ec9237afa3953eaa56a9a37f/f47df/crowd-informatics.webp 1600w","type":"image/webp","sizes":"(min-width: 1600px) 1600px, 100vw"}]},"width":1600,"height":650}}},{"id":"9ef69e63-5061-560c-bc51-5bee5433fb32","title":"EPI2ME Labs Tutorials","slug":"/nbindex/","link":null,"excerpt":"Development of EPI2ME Labs notebooks is currently on hold while we focus\non expanding our range ofâ€¦","timeToRead":2,"featured":false,"thumbnailText":null,"date":"September 01, 2020","category":null,"author":null,"thumbnail":{"__typename":"ImageSharp","ImageSharp_vertical":{"layout":"constrained","backgroundColor":"#e8e8e8","images":{"fallback":{"src":"/static/d5f2779e5a84bf92e5d939ed7cc9b20e/144fe/thumbnail.jpg","srcSet":"/static/d5f2779e5a84bf92e5d939ed7cc9b20e/9d7b9/thumbnail.jpg 190w,\n/static/d5f2779e5a84bf92e5d939ed7cc9b20e/144fe/thumbnail.jpg 380w","sizes":"(min-width: 380px) 380px, 100vw"},"sources":[{"srcSet":"/static/d5f2779e5a84bf92e5d939ed7cc9b20e/228d6/thumbnail.webp 190w,\n/static/d5f2779e5a84bf92e5d939ed7cc9b20e/6b99c/thumbnail.webp 380w","type":"image/webp","sizes":"(min-width: 380px) 380px, 100vw"}]},"width":380,"height":290},"ImageSharp_hero":{"layout":"constrained","backgroundColor":"#e8e8e8","images":{"fallback":{"src":"/static/d5f2779e5a84bf92e5d939ed7cc9b20e/5e493/thumbnail.jpg","srcSet":"/static/d5f2779e5a84bf92e5d939ed7cc9b20e/696c0/thumbnail.jpg 800w,\n/static/d5f2779e5a84bf92e5d939ed7cc9b20e/5e493/thumbnail.jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"},"sources":[{"srcSet":"/static/d5f2779e5a84bf92e5d939ed7cc9b20e/c9f06/thumbnail.webp 800w,\n/static/d5f2779e5a84bf92e5d939ed7cc9b20e/f47df/thumbnail.webp 1600w","type":"image/webp","sizes":"(min-width: 1600px) 1600px, 100vw"}]},"width":1600,"height":650}}},{"id":"ee17eb21-6e08-5b68-bd8b-d24ba70cf982","title":"EPI2ME Workflows","slug":"/wfindex/","link":null,"excerpt":"EPI2ME Labs maintains a collection of  Nextflow  bioinformatics\nworkflows tailored to Oxfordâ€¦","timeToRead":3,"featured":true,"thumbnailText":null,"date":"September 01, 2020","category":null,"author":null,"thumbnail":{"__typename":"ImageSharp","ImageSharp_vertical":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/4e2270a62f7d75abca53f001f87cc371/144fe/thumbnail.jpg","srcSet":"/static/4e2270a62f7d75abca53f001f87cc371/9d7b9/thumbnail.jpg 190w,\n/static/4e2270a62f7d75abca53f001f87cc371/144fe/thumbnail.jpg 380w","sizes":"(min-width: 380px) 380px, 100vw"},"sources":[{"srcSet":"/static/4e2270a62f7d75abca53f001f87cc371/228d6/thumbnail.webp 190w,\n/static/4e2270a62f7d75abca53f001f87cc371/6b99c/thumbnail.webp 380w","type":"image/webp","sizes":"(min-width: 380px) 380px, 100vw"}]},"width":380,"height":290},"ImageSharp_hero":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/4e2270a62f7d75abca53f001f87cc371/5e493/thumbnail.jpg","srcSet":"/static/4e2270a62f7d75abca53f001f87cc371/696c0/thumbnail.jpg 800w,\n/static/4e2270a62f7d75abca53f001f87cc371/5e493/thumbnail.jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"},"sources":[{"srcSet":"/static/4e2270a62f7d75abca53f001f87cc371/c9f06/thumbnail.webp 800w,\n/static/4e2270a62f7d75abca53f001f87cc371/f47df/thumbnail.webp 1600w","type":"image/webp","sizes":"(min-width: 1600px) 1600px, 100vw"}]},"width":1600,"height":650}}}]},"previous":{"id":"3d042fca-edb2-5431-833f-65ee08199bac","slug":"/workflows/wf-artic/","title":"wf-artic documentation"},"next":{"id":"fbea9741-8360-5f8a-aa27-c89dd5317c5e","slug":"/workflows/wf-alignment/","title":"wf-alignment documentation"}},"pageContext":{"id":"1a47f5ba-11d4-5e2b-a748-ecfd43472404","categoryId":null,"tagsIds":[],"hasTags":false,"previousId":"3d042fca-edb2-5431-833f-65ee08199bac","nextId":"fbea9741-8360-5f8a-aa27-c89dd5317c5e","paginatePostsPage":false,"basePath":"/","services":{"algolia":true,"mailchimp":false,"disqus":false,"graphComment":false,"facebookComment":false},"siteUrl":"https://labs.epi2me.io","mobileMenu":{"title":"Topics","items":[{"name":"Articles","slug":"/category/articles/"},{"name":"How Tos","slug":"/category/how-tos/"},{"name":"Data Releases","slug":"/category/data-releases/"},{"name":"Software Releases","slug":"/category/software-releases/"}]},"darkMode":true,"includeExcerpt":true,"includeTimeToRead":true,"includeTableOfContents":true,"imageQuality":75}},"staticQueryHashes":["1711681201","1992822086","2241067151","2409295108","2893703372","3667468360"],"slicesMap":{}}