{"componentChunkName":"component---packages-blog-gatsby-blog-core-src-templates-post-js","path":"/workflows/wf-single-cell/","result":{"data":{"post":{"id":"73cd81d3-f4be-5e5d-aecb-ef540ffb2106","title":"wf-single-cell documentation","slug":"/workflows/wf-single-cell/","link":null,"excerpt":"Single cell workflow Identification of cell- and UMI barcodes from single-cell sequencingâ€¦","tableOfContents":{"items":[{"url":"#single-cell-workflow","title":"Single cell workflow","items":[{"url":"#introduction","title":"Introduction"},{"url":"#compute-requirements","title":"Compute requirements"},{"url":"#install-and-run","title":"Install and run"},{"url":"#related-protocols","title":"Related protocols"},{"url":"#input-example","title":"Input example"},{"url":"#input-parameters","title":"Input parameters"},{"url":"#outputs","title":"Outputs"},{"url":"#pipeline-overview","title":"Pipeline overview"},{"url":"#troubleshooting","title":"Troubleshooting"},{"url":"#faqs","title":"FAQ's"},{"url":"#related-blog-posts","title":"Related blog posts"},{"url":"#related-blog-posts-1","title":"Related blog posts"}]}]},"timeToRead":10,"featured":null,"protected":null,"thumbnailText":null,"date":null,"category":null,"author":{"id":"06b83e26-dbcb-5a79-ab90-35cd748fd03f","name":"EPI2ME Labs","slug":"/author/epi2me-labs/","title":"Senior Button Pusher","description":"I'm a robot. I like to publish JupyterLab tutorials, Nextflow workflows, and blog posts.","skills":["Continuous Deployment"],"social":[{"name":"Twitter","url":"https://twitter.com/nanopore"},{"name":"Website","url":"https://labs.epi2me.io"}],"status":"bot","thumbnail":{"__typename":"ImageSharp","ImageSharp_small":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAACg0lEQVR42pVUy4tSYRTXO6EbH4GEKxc+wShBXE0gCNJ/oJsgTFxUmxbVrCSlrQvdVTMuRnQng6AJCeIqwhajqG1EBEloKRk+rnofX+dcviuDjVc7cDjfPed8P37n8V2V6nZhCCEM2Kdarfa70+mcu1yuOZ7B96xYLJ6AVauOFClRrVZ/ikQiZDQaCQAuoo7HYyEajRKIXSaTSeZm/j45ofZ5KBQiq9VqPZ1OudlsJq7Xa3EymXCCILAYg5xXO3f2i9lsbpbLZRIIBBY+n285HA65xWLBB4PBOX6fn59zFoulia1RYik7TV6vd7TZbAgA8f1+n6clEyiZ7/V6PLAkbrf7F+QajilbpdFovtVqNcRAMIHa7RljkPP1FjL/Tpfahzqd7jocDovpdFosFAoEFc/QP1Gv119jzs6dvSW7QG1Go/Eu2MegL0HPqL5AH8ZghWw0dy9DeVoXDoeDWK3WHyaT6bPBYLiE8j6g4hl9Nputa7fbcdIflSYtO9/l83mpfzAQ0m63SbPZlLTVahH0gXC5XA4BE/TOHSXAJ/F4XALkOE6kg5AHI1Afl0gkEDByDOApNH5DLxNcEVSe5wksuQDrJL0aGNgKch8pDUZu7D2Px/MTFhlZiiBoCQAJ2WyWBb9wYw9Nh9ZGCjAM86Xb7SKOdFmqn+fFRqOxwnI7nQ6BKVcxF76PesuvU6mU3EcJEHtXqVRYJJvJZLB/b5T6t7vYD+Ad/wZ225IBUCiVSuxyueQh9gdy7h9a7N1eXtXr9S1L+POIg8GArVaryO7qmHJ3WZ76/f4VsNzI/0Mkir5D01UCfR+LxQjLsjwq/lzR979g29JpSWfwDMeocH5LfXtL/QsFNN8CNdlHZwAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/c489ff6e3b007deccb15ccbd6b76ce51/a7a66/epi2melabs.png","srcSet":"/static/c489ff6e3b007deccb15ccbd6b76ce51/a7a66/epi2melabs.png 48w,\n/static/c489ff6e3b007deccb15ccbd6b76ce51/416a0/epi2melabs.png 96w","sizes":"48px"},"sources":[{"srcSet":"/static/c489ff6e3b007deccb15ccbd6b76ce51/a3542/epi2melabs.webp 48w,\n/static/c489ff6e3b007deccb15ccbd6b76ce51/0f66d/epi2melabs.webp 96w","type":"image/webp","sizes":"48px"}]},"width":48,"height":48},"ImageSharp_regular":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAACg0lEQVR42pVUy4tSYRTXO6EbH4GEKxc+wShBXE0gCNJ/oJsgTFxUmxbVrCSlrQvdVTMuRnQng6AJCeIqwhajqG1EBEloKRk+rnofX+dcviuDjVc7cDjfPed8P37n8V2V6nZhCCEM2Kdarfa70+mcu1yuOZ7B96xYLJ6AVauOFClRrVZ/ikQiZDQaCQAuoo7HYyEajRKIXSaTSeZm/j45ofZ5KBQiq9VqPZ1OudlsJq7Xa3EymXCCILAYg5xXO3f2i9lsbpbLZRIIBBY+n285HA65xWLBB4PBOX6fn59zFoulia1RYik7TV6vd7TZbAgA8f1+n6clEyiZ7/V6PLAkbrf7F+QajilbpdFovtVqNcRAMIHa7RljkPP1FjL/Tpfahzqd7jocDovpdFosFAoEFc/QP1Gv119jzs6dvSW7QG1Go/Eu2MegL0HPqL5AH8ZghWw0dy9DeVoXDoeDWK3WHyaT6bPBYLiE8j6g4hl9Nputa7fbcdIflSYtO9/l83mpfzAQ0m63SbPZlLTVahH0gXC5XA4BE/TOHSXAJ/F4XALkOE6kg5AHI1Afl0gkEDByDOApNH5DLxNcEVSe5wksuQDrJL0aGNgKch8pDUZu7D2Px/MTFhlZiiBoCQAJ2WyWBb9wYw9Nh9ZGCjAM86Xb7SKOdFmqn+fFRqOxwnI7nQ6BKVcxF76PesuvU6mU3EcJEHtXqVRYJJvJZLB/b5T6t7vYD+Ad/wZ225IBUCiVSuxyueQh9gdy7h9a7N1eXtXr9S1L+POIg8GArVaryO7qmHJ3WZ76/f4VsNzI/0Mkir5D01UCfR+LxQjLsjwq/lzR979g29JpSWfwDMeocH5LfXtL/QsFNN8CNdlHZwAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/c489ff6e3b007deccb15ccbd6b76ce51/46e60/epi2melabs.png","srcSet":"/static/c489ff6e3b007deccb15ccbd6b76ce51/46e60/epi2melabs.png 150w,\n/static/c489ff6e3b007deccb15ccbd6b76ce51/d612b/epi2melabs.png 300w","sizes":"150px"},"sources":[{"srcSet":"/static/c489ff6e3b007deccb15ccbd6b76ce51/ae23d/epi2melabs.webp 150w,\n/static/c489ff6e3b007deccb15ccbd6b76ce51/bd37b/epi2melabs.webp 300w","type":"image/webp","sizes":"150px"}]},"width":150,"height":150}}},"body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"wf-single-cell documentation\",\n  \"slug\": \"workflows/wf-single-cell\",\n  \"author\": \"EPI2ME Labs\",\n  \"private\": true,\n  \"category\": \"Workflows\",\n  \"keywords\": [\"epi2melabs\", \"nanopore sequencing\"],\n  \"description\": \"Documentation for the wf-single-cell workflow.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"single-cell-workflow\"\n  }, \"Single cell workflow\"), mdx(\"p\", null, \"Identification of cell- and UMI barcodes from single-cell sequencing.\"), mdx(\"h2\", {\n    \"id\": \"introduction\"\n  }, \"Introduction\"), mdx(\"p\", null, \"This workflow extracts cell barcodes and UMIs from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.10xgenomics.com/\"\n  }, \"10x\"), \"-generated single cell libraries.\\nIt was initially created as a Nextflow port of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/nanoporetech/sockeye\"\n  }, \"Sockeye\"), \".\"), mdx(\"p\", null, \"In brief, the workflow does the following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Adapter identification, fused read splitting and stranding.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mapping of reads to genomic reference.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Gene and transcript read assignment.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Cell barcode and UMI extraction and correction.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Generation of gene and transcript count matrices for unique UMIs.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Tagging BAM files with cell barcodes and UMIs.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Calculation of library saturation.\")), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/shimlab/BLAZE\"\n  }, \"BLAZE\"), \" preprint provided useful benchmarking of the original sockeye implementation.\\nThis assisted in the selection of appropriate thresholds for cell cut-off and for defining the limits of the gene x cell matrix.\"), mdx(\"p\", null, \"The isoform selection procedure used in this workflow was adapted from that found in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/LuyiTian/FLAMES\"\n  }, \"FLAMES\"), \"\\npackage.\"), mdx(\"h2\", {\n    \"id\": \"compute-requirements\"\n  }, \"Compute requirements\"), mdx(\"p\", null, \"Recommended requirements:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"CPUs = 64\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Memory = 256GB\")), mdx(\"p\", null, \"Minimum requirements:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"CPUs = 8\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Memory = 32GB\")), mdx(\"p\", null, \"Approximate run time: Approximately 8h for 120M reads with the recommended requirements.\"), mdx(\"p\", null, \"ARM processor support: False\"), mdx(\"h2\", {\n    \"id\": \"install-and-run\"\n  }, \"Install and run\"), mdx(\"p\", null, \"These are instructions to install and run the workflow on command line. You can also access the workflow via the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://labs.epi2me.io/downloads/\"\n  }, \"EPI2ME application\"), \".\"), mdx(\"p\", null, \"The workflow uses \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.nextflow.io/\"\n  }, \"Nextflow\"), \" to manage compute and software resources, therefore nextflow will need to be installed before attempting to run the workflow.\"), mdx(\"p\", null, \"The workflow can currently be run using either \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.docker.com/products/docker-desktop\"\n  }, \"Docker\"), \" or\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.sylabs.io/guides/3.0/user-guide/index.html\"\n  }, \"Singularity\"), \" to provide isolation of\\nthe required software. Both methods are automated out-of-the-box provided\\neither docker or singularity is installed. This is controlled by the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.nextflow.io/docs/latest/config.html#config-profiles\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"-profile\")), \" parameter as exemplified below.\"), mdx(\"p\", null, \"It is not required to clone or download the git repository in order to run the workflow.\\nMore information on running EPI2ME workflows can be found on our \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://labs.epi2me.io/wfindex\"\n  }, \"website\"), \".\"), mdx(\"p\", null, \"The following command can be used to obtain the workflow. This will pull the repository in to the assets folder of nextflow and provide a list of all parameters available for the workflow as well as an example command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"nextflow run epi2me-labs/wf-single-cell \\u2013-help\\n\")), mdx(\"p\", null, \"A demo dataset is provided for testing of the workflow. It can be downloaded using:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"wget https://ont-exd-int-s3-euwst1-epi2me-labs.s3.amazonaws.com/wf-single-cell/wf-single-cell-demo.tar.gz \\\\\\n    && tar -xzvf wf-single-cell-demo.tar.gz\\n\")), mdx(\"p\", null, \"The workflow can be run with the demo data using:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"nextflow run epi2me-labs/wf-single-cell \\\\\\n    --expected_cells 100 \\\\\\n    --fastq 'wf-single-cell-demo/chr17.fq.gz' \\\\\\n    --kit_name '3prime' \\\\\\n    --kit_version 'v3' \\\\\\n    --ref_genome_dir 'wf-single-cell-demo' \\\\\\n    --umap_plot_genes 'wf-single-cell-demo/umap_plot_genes.csv'\\n\")), mdx(\"p\", null, \"For further information about running a workflow on the cmd line see \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://labs.epi2me.io/wfquickstart/\"\n  }, \"https://labs.epi2me.io/wfquickstart/\")), mdx(\"h2\", {\n    \"id\": \"related-protocols\"\n  }, \"Related protocols\"), mdx(\"p\", null, \"This workflow is designed to take input sequences that have been produced from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://nanoporetech.com/\"\n  }, \"Oxford Nanopore Technologies\"), \" devices.\"), mdx(\"p\", null, \"Find related protocols in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://community.nanoporetech.com/docs/\"\n  }, \"Nanopore community\"), \".\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://community.nanoporetech.com/docs/prepare/library_prep_protocols/ligation-sequencing-v14-single-cell-transcriptomics-with-5-cdna/v/sst_9204_v114_revd_06mar2024\"\n  }, \"Library prep and sequencing protocol for the 10x 5\\u2019 kit\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://community.nanoporetech.com/docs/prepare/library_prep_protocols/single-cell-transcriptomics-with-cdna-prepared-using-10x/v/sst_9198_v114_reve_06dec2023\"\n  }, \"Library prep and sequencing protocol for the 10x 3\\u2019 kit\"))), mdx(\"h2\", {\n    \"id\": \"input-example\"\n  }, \"Input example\"), mdx(\"p\", null, \"This workflow accepts either FASTQ or BAM files as input.\"), mdx(\"p\", null, \"The FASTQ or BAM input parameters for this workflow accept one of three cases: (i) the path to a single FASTQ or BAM file; (ii) the path to a top-level directory containing FASTQ or BAM files; (iii) the path to a directory containing one level of sub-directories which in turn contain FASTQ or BAM files. In the first and second cases (i and ii), a sample name can be supplied with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--sample\"), \". In the last case (iii), the data is assumed to be multiplexed with the names of the sub-directories as barcodes. In this case, a sample sheet can be provided with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--sample_sheet\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(i)                     (ii)                 (iii)    \\ninput_reads.fastq   \\u2500\\u2500\\u2500 input_directory  \\u2500\\u2500\\u2500 input_directory\\n                        \\u251C\\u2500\\u2500 reads0.fastq     \\u251C\\u2500\\u2500 barcode01\\n                        \\u2514\\u2500\\u2500 reads1.fastq     \\u2502   \\u251C\\u2500\\u2500 reads0.fastq\\n                                             \\u2502   \\u2514\\u2500\\u2500 reads1.fastq\\n                                             \\u251C\\u2500\\u2500 barcode02\\n                                             \\u2502   \\u251C\\u2500\\u2500 reads0.fastq\\n                                             \\u2502   \\u251C\\u2500\\u2500 reads1.fastq\\n                                             \\u2502   \\u2514\\u2500\\u2500 reads2.fastq\\n                                             \\u2514\\u2500\\u2500 barcode03\\n                                              \\u2514\\u2500\\u2500 reads0.fastq\\n\")), mdx(\"h2\", {\n    \"id\": \"input-parameters\"\n  }, \"Input parameters\"), mdx(\"h3\", {\n    \"id\": \"input-options\"\n  }, \"Input Options\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Nextflow parameter name\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Help\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Default\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"fastq\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"FASTQ files to use in the analysis.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"This accepts one of three cases: (i) the path to a single FASTQ file; (ii) the path to a top-level directory containing FASTQ files; (iii) the path to a directory containing one level of sub-directories which in turn contain FASTQ files. In the first and second case, a sample name can be supplied with \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"--sample\"), \". In the last case, the data is assumed to be multiplexed with the names of the sub-directories as barcodes. In this case, a sample sheet can be provided with \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"--sample_sheet\"), \".\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"bam\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"BAM or unaligned BAM (uBAM) files to use in the analysis.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"This accepts one of three cases: (i) the path to a single BAM file; (ii) the path to a top-level directory containing BAM files; (iii) the path to a directory containing one level of sub-directories which in turn contain BAM files. In the first and second case, a sample name can be supplied with \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"--sample\"), \". In the last case, the data is assumed to be multiplexed with the names of the sub-directories as barcodes. In this case, a sample sheet can be provided with \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"--sample_sheet\"), \".\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"ref_genome_dir\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The path to the 10x reference directory\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Human reference data can be downloaded from 10x \", mdx(\"a\", {\n    parentName: \"td\",\n    \"href\": \"https://cf.10xgenomics.com/supp/cell-exp/refdata-gex-GRCh38-2020-A.tar.gz\"\n  }, \"here\"), \". Instructions for preparing reference data can be found \", mdx(\"a\", {\n    parentName: \"td\",\n    \"href\": \"https://www.10xgenomics.com/support/software/cell-ranger/tutorials/cr-tutorial-mr#overview\"\n  }, \"here\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"kit\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The 10x kit and version separated by a colon (eg: 3prime:v3)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"10x kits can be released with different versions, each requiring a specific whitelist that is looked-up by the workflow. If \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"single_cell_sample_sheet\"), \" is not defined, the 10x kit is applied to all samples. This parameter is ignored if \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"single_cell_sample_sheet\"), \" is supplied.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3prime:v3\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"expected_cells\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Number of expected cells in the sample.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The number of expected cells. If \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"single_cell_sample_sheet\"), \" is not defined, \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"expected_cells\"), \" is applied to all samples. This parameter is ignored if \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"single_cell_sample_sheet\"), \" is supplied.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"500\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"full_length_only\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"boolean\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Only process full length reads.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"If set to true, only process reads or subreads that are classified as full length (read segments flanked by compatible adapters in the expected orientation).\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"True\")))), mdx(\"h3\", {\n    \"id\": \"sample-options\"\n  }, \"Sample Options\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Nextflow parameter name\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Help\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Default\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"single_cell_sample_sheet\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"An optional CSV file used to assign library metadata to the different samples. If all samples have the same library metadata, this can be supplied instead by using the parameters (kit, expected cells).\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Columns should be: \", \"[sample_id, kit, exp_cells]\", \". This must not be confused with the MinKNOW sample_sheet. \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"sample_id\"), \" should correspond to \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"sample_name\"), \" which is defined either in the \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"sample_sheet\"), \", given by the \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"sample\"), \" parameter (for single sample runs) or if no \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"sample_sheet\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"sample\"), \" is given, is derived from the folder name containing the FASTQ files.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"sample_sheet\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"A CSV file used to map barcodes to sample aliases. The sample sheet can be provided when the input data is a directory containing sub-directories with FASTQ files.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The sample sheet is a CSV file with, minimally, columns named \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"barcode\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"alias\"), \". Extra columns are allowed. A \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"type\"), \" column is required for certain workflows and should have the following values; \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"test_sample\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"positive_control\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"negative_control\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"no_template_control\"), \".\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"sample\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"A single sample name for non-multiplexed data. Permissible if passing a single .fastq(.gz) file or directory of .fastq(.gz) files.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })))), mdx(\"h3\", {\n    \"id\": \"output-options\"\n  }, \"Output Options\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Nextflow parameter name\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Help\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Default\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"out_dir\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Directory for output of all workflow results.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"output\")))), mdx(\"h3\", {\n    \"id\": \"advanced-options\"\n  }, \"Advanced options\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Nextflow parameter name\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Help\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Default\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"kit_config\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"A file defining the configurations associated with the various supported 10x kits.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"A CSV file is expected with the following headers \", \"[kit, barcode_length, umi_length]\", \". If not specified, a default \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"kit_configs.csv\"), \" (found in the project directory root) will be used. This parameter does not typically need be changed.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"threads\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Number of CPU threads to use in resource intensive processes.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The total CPU resource used by the workflow is constrained by the executor configuration.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"8\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"fastq_chunk\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Sets the maximum number of reads per chunk for the initial processing of reads.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Controls batching of reads for processing.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1000000\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"barcode_adapter1_suff_length\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Suffix length of the read1 adapter to use in creating the probe sequence for identifying barcode/UMI bases.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"For example, specifying 12 would mean that the last 12 bases of the specified read1 sequence will be included in the probe sequence.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"10\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"barcode_min_quality\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Minimum allowed nucleotide-level quality score in the extracted/uncorrected barcode sequence.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Values equal or higher to this this will be considered \\u2018high-quality\\u2019 and used for generating the barcode whitelist.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"15\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"barcode_max_ed\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Maximum allowable edit distance between uncorrected barcode and the best matching corrected barcode from the sample whitelist.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Barcodes are corrected by searching from a list of barcodes known to exist in the dataset. A maximum edit distance of 2 between query and whitelist barcode is recommended.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"barcode_min_ed_diff\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Minimum allowable edit distance difference between whitelist barcode candidates.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"If there is more than one candidate barcode found in the whitelist, the edit distance difference of the top hit and second best hits (in relation to the uncorrected barcode) must be at least this value to be able to assign a barcode. If the edit distance difference is less than this, it is assumed that barcode identity is amiguous, and the read is not tagged with a corrected barcode.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"gene_assigns_minqv\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Minimum MAPQ score allowed for a read to be assigned to a gene.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"30\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"matrix_min_genes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Filter cells from the gene expression matrix if they contain fewer than <matrix_min_genes> genes.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"200\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"matrix_min_cells\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Filter genes from the gene expression matrix that are observed in fewer than <matrix_min_cells> cells.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"matrix_max_mito\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Filter cells from the gene expression matrix if more than <matrix_max_mito> percent of UMI counts come from mitochondrial genes.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"20\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"matrix_norm_count\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Normalize expression matrix to <matrix_norm_count> counts per cell.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"10000\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"umap_plot_genes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"File containing a list of gene symbols (one symbol per line) to annotate with expression values in the UMAP projections.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"mito_prefix\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Gene name prefix to identify for mitochondrial genes.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Parts of the workflow analyse mitochondrial genes separately. These genes are identified by searching for a gene name prefix. Human mitochondrial genes can be identified with prefix \\u2018MT-\\u2019 and mouse genes with prefix \\u2018mt-\\u2019. If the reference genome contains data from multiple organisms with different nomenclature, multiple prefixes can be supplied like so: \\u2018MT-,mt-\\u2019\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"MT-\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"umap_n_repeats\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"integer\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Number of UMAP projection to repeat for each dataset.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The UMAP algorithm contains elements of randomness that can mislead users into seeing associations between cells that are not meaningful. It is recommended to view multiple plots generated with the same parameters and check that any observed structure is consistent across runs.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"stringtie_opts\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"string\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"StringTie options for transcriptome assembly.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"StringTie option string can be supplied at the command line as in this example: \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"--stringtie_opts=\\\"-c 5 -m 100 \\\"\"), \". StringTie options can be found here: \", mdx(\"a\", {\n    parentName: \"td\",\n    \"href\": \"http://ccb.jhu.edu/software/stringtie/index.shtml?t=manual\"\n  }, \"http://ccb.jhu.edu/software/stringtie/index.shtml?t=manual\"), \". The default option (-c 2) ensures that only transcripts with a coverage of 2 or higher are included in the generated transcriptome\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"-c 2\")))), mdx(\"h2\", {\n    \"id\": \"outputs\"\n  }, \"Outputs\"), mdx(\"p\", null, \"Output files may be aggregated including information for all samples or provided per sample. Per-sample files will be prefixed with respective aliases and represented below as {{ alias }}.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Title\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"File path\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Per sample or aggregated\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"workflow report\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./wf-single-cell-report.html\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Report for all samples\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"aggregated\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Concatenated sequence data\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./fastq_ingress_results/reads/{{ alias }}.fastq.gz\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Per sample reads concatenated in a single FASTQ file.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Results summaries\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/config_stats.json\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Results summaries including adapter configuration numbers.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Gene expression counts\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/gene_expression.counts.tsv\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Gene x cell expression matrix.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Processed gene expression counts\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/gene_expression.processed.tsv\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Filtered and normalized gene x cell expression matrix.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Transcript expression counts\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/transcript_expression.counts.tsv\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Transcript x cell expression matrix.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Processed transcript expression counts\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/transcript_expression.processed.tsv\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Filtered and normalized transcript x cell expression matrix.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Mitochondrial expression levels\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/gene_expression.mito.tsv\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Per cell mitochondrial gene expression as percentage total of total gene expression.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Read summary\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/read_summary.tsv\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Per read assigned barcodes UMIs genes and transcripts.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Barcode counts\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/uncorrected_bc_counts.tsv\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The counts of each barcode present in the sequenced library (only barcodes that have a 100% match in the 10x whitelist are included).\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Whitelist\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/whitelist.tsv\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"The barcodes found in the library that remain after filtering.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Alignment output per sample\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/tagged.bam\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Genomic alignment output file.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Alignment index per sample\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/tagged.bam.bai\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Genomic alignment index file.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Transcriptome sequence\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/transcriptome.fa.gz\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Transcriptome generated by Stringtie during transcript discovery stage\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Transcriptome annotation\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"./{{ alias }}/transcriptome.gff.gz\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Transcriptome annotation generated by Stringtie during transcript discovery stage\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"per-sample\")))), mdx(\"h2\", {\n    \"id\": \"pipeline-overview\"\n  }, \"Pipeline overview\"), mdx(\"p\", null, \"The following section details the main steps of the workflow. \"), mdx(\"h3\", {\n    \"id\": \"1-concatenates-input-files-and-generate-per-read-stats\"\n  }, \"1. Concatenates input files and generate per read stats.\"), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/epi2me-labs/fastcat\"\n  }, \"fastcat/bamstats\"), \" tool is used to concatenate multi-file samples to be processed by the workflow. It will also output per read stats including average read lengths and qualities.\"), mdx(\"h3\", {\n    \"id\": \"2-stranding-and-identification-of-full-length-reads\"\n  }, \"2. Stranding and identification of full-length reads\"), mdx(\"p\", null, \"Reads derived from a 10x Genomics library will ideally be flanked by two different adapter\\nsequences. These reads are more likely to represent full length mRNA molecules,\\nalthough that isn\\u2019t guaranteed as some cDNAs may have been created by internal\\npriming or represent other cDNA synthesis artifacts. See this \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://cdn.10xgenomics.com/image/upload/v1660261286/support-documents/CG000376_TechNote_Antisense_Intronic_Reads_SingleCellGeneExpression_RevA.pdf\"\n  }, \"10x Genomics Technical Note\"), \" for more information.\"), mdx(\"p\", null, \"This stage of the workflow assigns an adapter configuration to each read.\\nThis assigned configurations allows the stranding and orientating the reads.\\nThe following schematic shows an example read structure from 10x Genomics 3\", \"\\u2032\", \" library .\"), mdx(\"figure\", null, mdx(\"img\", {\n    src: \"docs/images/3prime_read.png\",\n    alt: \"10x read structure\"\n  }), mdx(\"figcaption\", null, \"Fig.1 Read structure for 10x 3prime kit reads\")), mdx(\"p\", null, \"Adapter are located within the reads using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/torognes/vsearch\"\n  }, \"vsearch\"), \" (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Read1\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TSO\"), \" in Fig.1 in the case of the 3prime kit).\\nThe table below details the adapter sequences for each of the 10x Genomics kits, along with links to the relevant user guides.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Kit\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"adapter1\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"adapter2\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"10x user guide\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3\", \"\\u2032\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"CTACACGACGCTCTTCCGATCT\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"ATGTACTCTGCGTTGATACCACTGCTT\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"a\", {\n    parentName: \"td\",\n    \"href\": \"https://cdn.10xgenomics.com/image/upload/v1660261285/support-documents/CG000204_ChromiumNextGEMSingleCell3_v3.1_Rev_D.pdf\"\n  }, \"3\\u2019 kit\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"multiome\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"CTACACGACGCTCTTCCGATCT\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"ATGTACTCTGCGTTGATACCACTGCTT\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"a\", {\n    parentName: \"td\",\n    \"href\": \"https://cdn.10xgenomics.com/image/upload/v1666737555/support-documents/CG000331_ChromiumNextGEMSingleCell5-v2_UserGuide_RevE.pdf\"\n  }, \"5\\u2019  kit\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"5\", \"\\u2032\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"CTACACGACGCTCTTCCGATCT\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"GTACTCTGCGTTGATACCACTGCTT\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"a\", {\n    parentName: \"td\",\n    \"href\": \"https://teichlab.github.io/scg_lib_structs/data/CG000338_ChromiumNextGEM_Multiome_ATAC_GEX_User_Guide_RevB.pdf\"\n  }, \"multiome kit\"))))), mdx(\"p\", null, \"Concatenated reads are identified by adapter configuration and are split into individual subreads and\\nreorientated if required.\\nThe following table details the various configurations and the actions taken for each.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"configuration\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"action\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Full length\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Reads are trimmed from each side and oriented and adapter2 is removed\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Single adapter1\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Reads are oriented and trimmed from adapter1 end only\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Single adapter2\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Reads are oriented and trimmed from the adapter2 end only\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"double adapter1\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Reads are trimmed from both sides\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"double adapter2\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Reads are trimmed from both sides\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"other\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"No valid adapters found; not used in further analysis\")))), mdx(\"p\", null, \"Adapter configuration summaries can be found in the output file  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{{ alias }}/{{ alias }}.config_stats.json\\\"\")), mdx(\"p\", null, \"To only process full length reads the option \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--full_length_only\"), \" should be set to true (default: true).\\nIf set to false, reads with only a single adapter or other non-full-length adapter configurations will also be processed.\"), mdx(\"h3\", {\n    \"id\": \"3-extract-cell-barcodes-and-umis\"\n  }, \"3. Extract cell barcodes and UMIs\"), mdx(\"p\", null, \"The next step is to extract 10x Genomics barcodes and UMI sequences from the stranded and trimmed reads.\"), mdx(\"p\", null, \"In order to do this, the first 100bp of each read are aligned to a reference probe using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/jeffdaily/parasail\"\n  }, \"parasail\"), \". This probe contains a suffix of the adapter1 sequence, some ambiguities (\\u201CNs\\u201D) representing the barcode and UMI, and a polyT tract.\"), mdx(\"figure\", null, mdx(\"img\", {\n    src: \"docs/images/probe.png\",\n    alt: \"probe image\"\n  }), mdx(\"figcaption\", null, \"Fig.2 Schematic of a 3\\u2032 v3 probe aligned to the read prefix\")), mdx(\"p\", null, \"In this case, the first 16bp of the read that aligns to the N probe region is where the barcode is expected to be, so\\nthis sequence is assigned as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uncorrected barcode\"), \".\\nThe following 12 bp are where the UMI is expected, and is assigned to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uncorrected umi\"), \".\"), mdx(\"p\", null, \"The probe sequence will vary depending on the size of the expected barcode and UMI, which can be found in the\\nfollowing table.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"kit\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"version\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"barcode length\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"UMI length\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3\", \"\\u2032\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"v2\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"16\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"10\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3\", \"\\u2032\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"v3\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"16\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"12\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"5\", \"\\u2032\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"v1\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"16\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"10\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"multiome\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"v1\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"16\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"12\")))), mdx(\"p\", null, \"Workflow options:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The size of the adapter1 suffix can be specified with: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"barcode_adapter1_suff_length\"))), mdx(\"p\", null, \"Once the barcode and UMI has been extracted, these are then trimmed from the reads along\\nwith the adapter1 sequence. These trimmed reads are then used in the alignment step.\"), mdx(\"h3\", {\n    \"id\": \"4-aligning-reads-to-genome\"\n  }, \"4. Aligning reads to genome\"), mdx(\"p\", null, \"The next stage is to align the preprocessed reads to the reference genome. This enables gene and transcript\\nread assignment in downstream steps.\"), mdx(\"p\", null, \"The stranded and trimmed FASTQ reads are mapped to the reference genome using minimap2.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"The parameter \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resources_mm2_max_threads int\"), \" controls the threads given to an alignment process.\\nOther optional parameters can be supplied to minimap2 using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resources_mm2_flags\"), \" (for example \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--resources_mm2_flags=\\\"-I 16GB\\\"\"), \").\"), mdx(\"h3\", {\n    \"id\": \"5-barcode-correction\"\n  }, \"5. Barcode correction\"), mdx(\"p\", null, \"The aim of this stage is to correct errors present in the previously extracted barcodes.\\n10x Genomics barcodes are not random; all possible barcode sequences can be found in a whitelist of known barcodes.\\nThe appropriate whitelist for each kit and version is chosen automatically by the workflow.\\nThe whitelist is used to generate a shortlist of high quality barcodes present in the sample, which is then used to\\ncorrect barcode errors.\"), mdx(\"p\", null, \"The correction proceeds as follows:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A shortlist of all high quality barcodes present in our sample is generated.\\nThis is done by adding an uncorrected barcode to the shortlist if it:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"has a min quality > \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"barcode_min_quality\"), \" (default 15)\")))), mdx(\"p\", null, \"In each cell library there are expected to be some low quality cells and empty droplets that can be identified by their low number of reads.\\nTo remove these cells, the shortlist is filtered with a quantile based threshold.\\nThis threshold is determined by ranking the cells by read count and taking the top n cells (n = \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"expected_cells\"), \").\\nThe read count 95th percentile / 20 is the threshold used. This threshold can be visualised in the knee plots generated by the workflow.\"), mdx(\"p\", null, \"For uncorrected barcodes not present in the shortlist, they are cross-referenced against the shortlist, and are assigned\\na barcode from this list if the candidate barcode meets the following criteria:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the query and closest-matched shortlist barcode have an edit distance <= 2\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The edit distance difference between the top and hit and second top hit in the shortlist >= 2\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"note\"), \": Edit distance here refers specifically to the Levenshtein distance, which is the minimum number of single base\\nchanges it would take to transform one UMI into another (including insertions, substitutions or deletions).\"), mdx(\"p\", null, \"Workflow options:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"barcode_max_ed\"), \": Max edit distance between the uncorrected barcode and the matching whitelist barcode (default 2).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"barcode_min_ed_diff\"), \": Min difference in edit distance between (1) the uncorrected barcode vs top hit and (2) uncorrected barcode vs runner-up hit (default 2).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"expected_cells\"), \": Number of expected cells. Enter the number of expected cells in the sample.\")), mdx(\"h3\", {\n    \"id\": \"6-gene-and-transcript-assignment\"\n  }, \"6. Gene and transcript assignment\"), mdx(\"p\", null, \"Now that barcodes and UMIs have been assigned, the next stage is to assign a gene and transcript to each read. \"), mdx(\"p\", null, \"The first step is to create a transcriptome using stringtie2 (using long read mode \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-L\"), \").\\nThe minimum required transcripts for a transcript to be called is 2. This can be changed, along with other stringtie settings using the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stringtie_opts\"), \" options (default \\u201C-c 2\\u201D). The resulting query transcriptome is then annotated with the supplied reference\\ngenome annotation using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://ccb.jhu.edu/software/stringtie/gffcompare.shtml\"\n  }, \"gffcompare\"), \", annotating query transcripts with reference transcript and gene metadata.\"), mdx(\"p\", null, \"The original reads are then mapped to this transcriptome, producing one or more alignments per read.\"), mdx(\"h4\", {\n    \"id\": \"transcript-assignment\"\n  }, \"Transcript assignment\"), mdx(\"p\", null, \"To assign a read to a transcript, we follow a similar procedure to that used by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/LuyiTian/FLAMES\"\n  }, \"FLAMES\"), \".\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Transcripts that map to intronic query transcripts (those mapping to query transcripts with gffcompare classes \", \"[\\u2018i\\u2019, \\u2018y\\u2019, \\u2018p\\u2019, \\u2018s\\u2019]\", \")\\nare set to unknown (-). This does not affect the gene assignment.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Any read that uniquely maps to the annotated transcriptome is assigned that transcript.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Any read that does not uniquely map to a transcript is processed with the following procedure:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Order alignments by alignment score (AS)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the top alignment has a better AS or query coverage than the second, and\\nhas a minimum transcript coverage of 0.4, assign to this transcript, else set as unknown (-)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the AS is the same between the 1st and 2nd alignment the choose the alignment that has the highest transcript coverage, if the coverage is > 0.8 \")))), mdx(\"h4\", {\n    \"id\": \"gene-assignment\"\n  }, \"Gene assignment\"), mdx(\"p\", null, \"For each read, the alignment with the highest genomic MAPQ score is used for gene assignemnt if this score > \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gene_assigns_minqv\"), \" (default 30).\\nThe gene ID is then derived from the transcript assigned in the transcript assignment step.\"), mdx(\"h3\", {\n    \"id\": \"7-umi-correction\"\n  }, \"7. UMI correction\"), mdx(\"p\", null, \"The next step is to correct UMI errors. The previous barcode correction step leveraged a\\nwhitelist of all potential barcodes, drastically narrowing the search space. However, UMIs are random sequences and so there is no way of knowing beforehand\\nwhich UMIs will be in our library. To reduce the UMI search space, the reads are initially clustered by assigned gene, or if\\nno gene is assigned, by genomic interval. This also has the effect of reducing the likelihood of UMI collisions which occur due to the number\\nof total reads in a library usually being significantly higher than the total possible number of UMIS (16.7 million combinations for a 12bp UMI).\"), mdx(\"p\", null, \"UMI clusters are then generated from these gene-clustered reads using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/CGATOxford/UMI-tools\"\n  }, \"UMI-tools\"), \" with\\na slightly modified version of the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://umi-tools.readthedocs.io/en/latest/the_methods.html\"\n  }, \"directional method\"), \".\\nFor this clustering, Levenshtein distance threshold is used (default 2) instead of Hamming distance, in order to account for UMI indels.\\nThe selected node of each cluster is the one with the highest number of reads and is used to assign a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"corrected_umi\"), \" to the rest of the reads in that cluster.\"), mdx(\"h3\", {\n    \"id\": \"8-make-expression-matrices\"\n  }, \"8. Make expression matrices\"), mdx(\"p\", null, \"The gene x cell and transcript x cell expression matrices are the main outputs of the workflow and can be used in further analysis of\\nthe single cell experiment. \"), mdx(\"p\", null, \"The expression matrices are generated by collapsing the corrected UMIs (counting each unique UMI once) and summing\\nthe counts of features (gene or transcript) per cell to give a feature x cell expression matrix (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*expression.counts.tsv\"), \").  \"), mdx(\"p\", null, \"The expression count matrices are further processed in the following way to give gene x cell processed matrices\\n(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*expression.processed.tsv\"), \"):\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Cells are dropped that contain less than \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"matrix_min_genes\"), \" genes or transcripts (default 200)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Genes are dropped which are present in fewer than \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"matrix_min_cells\"), \" (default 3)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Cells where mitochondrial genes make up more than \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"matrix_max_mito\"), \" (default 20%) are dropped\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Counts are normalized to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"matrix_norm_count\"), \" (default 10,000) reads/cell\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Normalized counts are finally log10 transformed\")), mdx(\"h3\", {\n    \"id\": \"9-tagging-bam-files\"\n  }, \"9. Tagging bam files\"), mdx(\"p\", null, \"BAM files generated from aligning reads to the reference genome are now tagged with the\\nfollowing information from the workflow. By default, the BAMs are output per chromosome, but can be concatenated\\ninto a single file per sampe using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"merge_bam\"), \". The new bam will contain the following tags:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"CB: corrected cell barcode sequence\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"CR: uncorrected cell barcode sequence\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"CY: Phred quality scores of the uncorrected cell barcode sequence\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"UB: corrected UMI sequence\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"UR: uncorrected UMI sequence\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"UY: Phred quality scores of the uncorrected UMI sequence\")), mdx(\"h3\", {\n    \"id\": \"10-calculate-library-saturation\"\n  }, \"10. Calculate library saturation\"), mdx(\"p\", null, \"Sequencing saturation is an estimate of the library complexity that has been captured in a sequencing run.\\nAs read depth per cell increases, the number of genes and distinct UMIs identified will increase at a rate that is\\ndependent on the complexity of the input library. \"), mdx(\"p\", null, \"Reads which have been assigned a corrected barcode, corrected UMI and gene\\nare subsampled by varying degrees and the resulting median reads/cell is plotted against either:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"median genes per cell: this gives an indication of the gene complexity captured and whether increasing read depth would lead\\nto significantly more genes being identified.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"median UMIs per cell: this gives an indication of the UMI complexity captured. If this plot plateaus out, it may indicate that\\nPCR duplicates represent a high proportion of the reads at higher sequencing depth.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sequencing saturation:  calculated as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1 - (number of unique UMIs across all cells / number of reads across all cells)\"), \". Values near 0 indicate that\\nvery few duplicate UMIs are being identified, whereas values nearer to 1 indicate a higher proportion of duplicate UMIs are being captured.\\n1 / (1 - sequencing saturation) can be used can be used to estimate how many additional reads would be required to identify a new UMI. For example, if the sequencing saturation is 0.5\\n(50%) then for each two new reads, one of those should represent a new UMI. If the sequencing saturation is lower, at 0.2\\nfor example, then on average 1.25 reads would need to be sequenced to obtain a new UMI.\")), mdx(\"h3\", {\n    \"id\": \"11-make-umap-plots\"\n  }, \"11. Make UMAP plots\"), mdx(\"p\", null, \"UMAP (Uniform Manifold Approximation and Projection) is a data visualisation algorithm used\\nfor dimensionality reduction. It aims to preserve the local structure and relationships in high-dimensional data (in this case a gene x cell count matrix)\\nwhen projecting it into a two-dimensional space. This allows structure within the data, such as cell type and state, to be visualised,\\nand can be useful for quality control and gaining an initial view of the data.  To generate UMAP plots use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"plot_umaps\"), \". The data used for the\\nUMAP generation are the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#Make-expression-matrices\"\n  }, \"processed expression matrices\")), mdx(\"p\", null, \"Several UMAP plots are created:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"gene expression plots show the gene expression UMAPs with each cell annotated with the mean gene expression count\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"mitochondrial expression plots are the same but annotated with mean mitochondrial expression\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"single gene expression UMAPs again show the gene expression UMAPs, but each plot is overlaid with a gene count data from a single gene.\\nThese genes of interest can be specified by adding gene names to a file with the path spcified by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"umap_plot_genes path/to/gene+names.csv\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"transcript expression plots shows the transcript expression UMAP plots with each cell annotated with the mean gene transcript count per cell\")), mdx(\"p\", null, \"The UMAP algorithm is stochastic, therefore analysing the same data multiple times, using identical parameters, can lead to visually different projections.\\nIn order to have some confidence in the observed results, it can be useful to run the projection multiple times.\\nThe number of repeated projections can be set with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"umap_n_repeats\"), \" (default 3)\"), mdx(\"h2\", {\n    \"id\": \"troubleshooting\"\n  }, \"Troubleshooting\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the workflow fails please run it with the demo data set to ensure the workflow itself is working. This will help us determine if the issue is related to the environment, input parameters or a bug.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"See how to interpret some common nextflow exit codes \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://labs.epi2me.io/trouble-shooting/\"\n  }, \"here\"), \".\")), mdx(\"p\", null, \"When using singularity the following error may occur:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"RuntimeError: cannot cache function 'rdist': no locator available for file '/home/epi2melabs/...'\\n\")), mdx(\"p\", null, \"If you receive this error we suggest using the following in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nextflow.config\"), \" file to set the cache directory to a location that is writable by the singularity container:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"profiles {\\n    singularity {\\n        singularity {\\n            enabled = true\\n            autoMounts = true\\n            runOptions = '--writable-tmpfs'\\n        }\\n    }\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"faqs\"\n  }, \"FAQ\\u2019s\"), mdx(\"p\", null, \"If your question is not answered here, please report any issues or suggestions on the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/epi2me-labs/wf-single-cell/issues\"\n  }, \"github issues\"), \" page or start a discussion on the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://community.nanoporetech.com/\"\n  }, \"community\"), \".\"), mdx(\"h2\", {\n    \"id\": \"related-blog-posts\"\n  }, \"Related blog posts\"), mdx(\"h2\", {\n    \"id\": \"related-blog-posts-1\"\n  }, \"Related blog posts\"), mdx(\"p\", null, \"See the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://labs.epi2me.io/\"\n  }, \"EPI2ME website\"), \" for lots of other resources and blog posts.\"));\n}\n;\nMDXContent.isMDXComponent = true;","keywords":["epi2melabs","nanopore sequencing"],"tags":null,"thumbnail":null},"categoryPosts":{"nodes":[{"id":"d1047258-00be-50dc-b0ee-df64285cc642","title":"London calling datasets 2024","slug":"/lc2024-datasets/","link":null,"excerpt":"We are excited to share these datasets which can be used to explore features of some of ourâ€¦","timeToRead":1,"featured":null,"thumbnailText":null,"date":"May 21, 2024","category":null,"author":null,"thumbnail":{"__typename":"ImageSharp","ImageSharp_vertical":{"layout":"constrained","backgroundColor":"#785848","images":{"fallback":{"src":"/static/75cd548901a71555b4bdc5badb8ba451/144fe/ears_pricked.jpg","srcSet":"/static/75cd548901a71555b4bdc5badb8ba451/9d7b9/ears_pricked.jpg 190w,\n/static/75cd548901a71555b4bdc5badb8ba451/144fe/ears_pricked.jpg 380w","sizes":"(min-width: 380px) 380px, 100vw"},"sources":[{"srcSet":"/static/75cd548901a71555b4bdc5badb8ba451/228d6/ears_pricked.webp 190w,\n/static/75cd548901a71555b4bdc5badb8ba451/6b99c/ears_pricked.webp 380w","type":"image/webp","sizes":"(min-width: 380px) 380px, 100vw"}]},"width":380,"height":290},"ImageSharp_hero":{"layout":"constrained","backgroundColor":"#785848","images":{"fallback":{"src":"/static/75cd548901a71555b4bdc5badb8ba451/5e493/ears_pricked.jpg","srcSet":"/static/75cd548901a71555b4bdc5badb8ba451/696c0/ears_pricked.jpg 800w,\n/static/75cd548901a71555b4bdc5badb8ba451/5e493/ears_pricked.jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"},"sources":[{"srcSet":"/static/75cd548901a71555b4bdc5badb8ba451/c9f06/ears_pricked.webp 800w,\n/static/75cd548901a71555b4bdc5badb8ba451/f47df/ears_pricked.webp 1600w","type":"image/webp","sizes":"(min-width: 1600px) 1600px, 100vw"}]},"width":1600,"height":650}}},{"id":"50f0c7a7-25ba-52bb-9add-0b666d124597","title":"Oxford Nanopore Open Data project","slug":"/dataindex/","link":null,"excerpt":"The Oxford Nanopore Technologies Open Data (ont-open-data) provides reference sequencing data fromâ€¦","timeToRead":1,"featured":true,"thumbnailText":null,"date":"August 24, 2022","category":null,"author":null,"thumbnail":{"__typename":"ImageSharp","ImageSharp_vertical":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/d625388ba09b90e0b9b8a67a5e80bdb7/144fe/thumbnail.jpg","srcSet":"/static/d625388ba09b90e0b9b8a67a5e80bdb7/9d7b9/thumbnail.jpg 190w,\n/static/d625388ba09b90e0b9b8a67a5e80bdb7/144fe/thumbnail.jpg 380w","sizes":"(min-width: 380px) 380px, 100vw"},"sources":[{"srcSet":"/static/d625388ba09b90e0b9b8a67a5e80bdb7/228d6/thumbnail.webp 190w,\n/static/d625388ba09b90e0b9b8a67a5e80bdb7/6b99c/thumbnail.webp 380w","type":"image/webp","sizes":"(min-width: 380px) 380px, 100vw"}]},"width":380,"height":290},"ImageSharp_hero":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/d625388ba09b90e0b9b8a67a5e80bdb7/5e493/thumbnail.jpg","srcSet":"/static/d625388ba09b90e0b9b8a67a5e80bdb7/696c0/thumbnail.jpg 800w,\n/static/d625388ba09b90e0b9b8a67a5e80bdb7/5e493/thumbnail.jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"},"sources":[{"srcSet":"/static/d625388ba09b90e0b9b8a67a5e80bdb7/c9f06/thumbnail.webp 800w,\n/static/d625388ba09b90e0b9b8a67a5e80bdb7/f47df/thumbnail.webp 1600w","type":"image/webp","sizes":"(min-width: 1600px) 1600px, 100vw"}]},"width":1600,"height":650}}},{"id":"a6deba78-2dec-5837-8bad-862595a85a3a","title":"EPI2ME Desktop","slug":"/about/","link":null,"excerpt":"Nanopore sequencing can provide a wealth of data.\nThe traditional model of biological data analysisâ€¦","timeToRead":1,"featured":true,"thumbnailText":null,"date":"September 01, 2020","category":null,"author":null,"thumbnail":{"__typename":"ImageSharp","ImageSharp_vertical":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/8d35c423ec9237afa3953eaa56a9a37f/144fe/crowd-informatics.jpg","srcSet":"/static/8d35c423ec9237afa3953eaa56a9a37f/9d7b9/crowd-informatics.jpg 190w,\n/static/8d35c423ec9237afa3953eaa56a9a37f/144fe/crowd-informatics.jpg 380w","sizes":"(min-width: 380px) 380px, 100vw"},"sources":[{"srcSet":"/static/8d35c423ec9237afa3953eaa56a9a37f/228d6/crowd-informatics.webp 190w,\n/static/8d35c423ec9237afa3953eaa56a9a37f/6b99c/crowd-informatics.webp 380w","type":"image/webp","sizes":"(min-width: 380px) 380px, 100vw"}]},"width":380,"height":290},"ImageSharp_hero":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/8d35c423ec9237afa3953eaa56a9a37f/5e493/crowd-informatics.jpg","srcSet":"/static/8d35c423ec9237afa3953eaa56a9a37f/696c0/crowd-informatics.jpg 800w,\n/static/8d35c423ec9237afa3953eaa56a9a37f/5e493/crowd-informatics.jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"},"sources":[{"srcSet":"/static/8d35c423ec9237afa3953eaa56a9a37f/c9f06/crowd-informatics.webp 800w,\n/static/8d35c423ec9237afa3953eaa56a9a37f/f47df/crowd-informatics.webp 1600w","type":"image/webp","sizes":"(min-width: 1600px) 1600px, 100vw"}]},"width":1600,"height":650}}},{"id":"9ef69e63-5061-560c-bc51-5bee5433fb32","title":"EPI2ME Labs Tutorials","slug":"/nbindex/","link":null,"excerpt":"Development of EPI2ME Labs notebooks is currently on hold while we focus\non expanding our range ofâ€¦","timeToRead":2,"featured":false,"thumbnailText":null,"date":"September 01, 2020","category":null,"author":null,"thumbnail":{"__typename":"ImageSharp","ImageSharp_vertical":{"layout":"constrained","backgroundColor":"#e8e8e8","images":{"fallback":{"src":"/static/d5f2779e5a84bf92e5d939ed7cc9b20e/144fe/thumbnail.jpg","srcSet":"/static/d5f2779e5a84bf92e5d939ed7cc9b20e/9d7b9/thumbnail.jpg 190w,\n/static/d5f2779e5a84bf92e5d939ed7cc9b20e/144fe/thumbnail.jpg 380w","sizes":"(min-width: 380px) 380px, 100vw"},"sources":[{"srcSet":"/static/d5f2779e5a84bf92e5d939ed7cc9b20e/228d6/thumbnail.webp 190w,\n/static/d5f2779e5a84bf92e5d939ed7cc9b20e/6b99c/thumbnail.webp 380w","type":"image/webp","sizes":"(min-width: 380px) 380px, 100vw"}]},"width":380,"height":290},"ImageSharp_hero":{"layout":"constrained","backgroundColor":"#e8e8e8","images":{"fallback":{"src":"/static/d5f2779e5a84bf92e5d939ed7cc9b20e/5e493/thumbnail.jpg","srcSet":"/static/d5f2779e5a84bf92e5d939ed7cc9b20e/696c0/thumbnail.jpg 800w,\n/static/d5f2779e5a84bf92e5d939ed7cc9b20e/5e493/thumbnail.jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"},"sources":[{"srcSet":"/static/d5f2779e5a84bf92e5d939ed7cc9b20e/c9f06/thumbnail.webp 800w,\n/static/d5f2779e5a84bf92e5d939ed7cc9b20e/f47df/thumbnail.webp 1600w","type":"image/webp","sizes":"(min-width: 1600px) 1600px, 100vw"}]},"width":1600,"height":650}}},{"id":"ee17eb21-6e08-5b68-bd8b-d24ba70cf982","title":"EPI2ME Workflows","slug":"/wfindex/","link":null,"excerpt":"EPI2ME Labs maintains a collection of  Nextflow  bioinformatics\nworkflows tailored to Oxfordâ€¦","timeToRead":3,"featured":true,"thumbnailText":null,"date":"September 01, 2020","category":null,"author":null,"thumbnail":{"__typename":"ImageSharp","ImageSharp_vertical":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/4e2270a62f7d75abca53f001f87cc371/144fe/thumbnail.jpg","srcSet":"/static/4e2270a62f7d75abca53f001f87cc371/9d7b9/thumbnail.jpg 190w,\n/static/4e2270a62f7d75abca53f001f87cc371/144fe/thumbnail.jpg 380w","sizes":"(min-width: 380px) 380px, 100vw"},"sources":[{"srcSet":"/static/4e2270a62f7d75abca53f001f87cc371/228d6/thumbnail.webp 190w,\n/static/4e2270a62f7d75abca53f001f87cc371/6b99c/thumbnail.webp 380w","type":"image/webp","sizes":"(min-width: 380px) 380px, 100vw"}]},"width":380,"height":290},"ImageSharp_hero":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/4e2270a62f7d75abca53f001f87cc371/5e493/thumbnail.jpg","srcSet":"/static/4e2270a62f7d75abca53f001f87cc371/696c0/thumbnail.jpg 800w,\n/static/4e2270a62f7d75abca53f001f87cc371/5e493/thumbnail.jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"},"sources":[{"srcSet":"/static/4e2270a62f7d75abca53f001f87cc371/c9f06/thumbnail.webp 800w,\n/static/4e2270a62f7d75abca53f001f87cc371/f47df/thumbnail.webp 1600w","type":"image/webp","sizes":"(min-width: 1600px) 1600px, 100vw"}]},"width":1600,"height":650}}}]},"previous":{"id":"5123c7f8-5928-56c8-91b1-bf43efb93ada","slug":"/workflows/wf-somatic-variation/","title":"wf-somatic-variation documentation"},"next":{"id":"eca17a7f-9ea3-5c8f-9831-5aa2bf52c5d5","slug":"/workflows/wf-pore-c/","title":"wf-pore-c documentation"}},"pageContext":{"id":"73cd81d3-f4be-5e5d-aecb-ef540ffb2106","categoryId":null,"tagsIds":[],"hasTags":false,"previousId":"5123c7f8-5928-56c8-91b1-bf43efb93ada","nextId":"eca17a7f-9ea3-5c8f-9831-5aa2bf52c5d5","paginatePostsPage":false,"basePath":"/","services":{"algolia":true,"mailchimp":false,"disqus":false,"graphComment":false,"facebookComment":false},"siteUrl":"https://labs.epi2me.io","mobileMenu":{"title":"Topics","items":[{"name":"Articles","slug":"/category/articles/"},{"name":"Data Releases","slug":"/category/data-releases/"},{"name":"How Tos","slug":"/category/how-tos/"},{"name":"Software Releases","slug":"/category/software-releases/"}]},"darkMode":true,"includeExcerpt":true,"includeTimeToRead":true,"includeTableOfContents":true,"imageQuality":75}},"staticQueryHashes":["1711681201","1992822086","2241067151","2409295108","2893703372","3667468360"],"slicesMap":{}}